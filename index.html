<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boss Respawn Tracker</title>
    <style>
        /* (All existing CSS remains the same) */
        body {
            font-family: Arial, sans-serif;
            margin: 10px;
            background-color: #f5f5f5;
            padding: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 15px;
            font-size: 24px;
        }
        
        h2 {
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 15px;
            border-radius: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 0;
            min-width: 600px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            font-size: 14px;
        }
        
        th {
            background-color: #f2f2f2;
            font-weight: bold;
            position: sticky;
            top: 0;
        }
        
        .fixed-boss-header {
            background-color: #ffeb3b !important;
            font-weight: bold;
        }
        
        .next-regular-respawn {
            background-color: #fff9c4; /* Light yellow */
            color: #333;
            font-weight: bold;
        }
        
        .next-fixed-respawn {
            background-color: #fff9c4; /* Light yellow */
            color: #333;
            font-weight: bold;
        }
        
        .time-remaining {
            color: black;
            font-weight: normal;
        }
        
        .time-urgent {
            color: #d32f2f;
            font-weight: normal;
        }
        
        .time-bold {
            font-weight: bold;
        }
        
        .last-updated {
            text-align: right;
            font-size: 0.8em;
            color: #777;
            margin-top: 10px;
        }
        
        .edit-btn {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .edit-btn:hover {
            background-color: #0b7dda;
        }
        
        .edit-input {
            width: 100%;
            padding: 6px;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .save-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .save-btn:hover {
            background-color: #45a049;
        }
        
        .cancel-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .cancel-btn:hover {
            background-color: #d32f2f;
        }
        
        .set-time-btn {
            background-color: #FF9800;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .set-time-btn:hover {
            background-color: #e68900;
        }
        
        .edit-controls {
            display: inline-block;
            margin-left: 5px;
        }
        
        .instructions {
            background-color: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            border-left: 4px solid #2196F3;
            font-size: 14px;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
            max-width: 80%;
            font-size: 14px;
        }
        
        .storage-status {
            text-align: center;
            margin-bottom: 15px;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .storage-connected {
            background-color: #e8f5e9;
            color: #2e7d32;
        }
        
        .storage-error {
            background-color: #ffebee;
            color: #c62828;
        }
        
        .update-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #4CAF50;
            margin-right: 5px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }
        
        .polling-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
        }
        
        /* GitHub Settings Styles */
        .github-settings-container {
            margin-bottom: 15px;
        }
        
        .password-protection {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .password-protection h3 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
        }
        
        .password-protection .form-group {
            margin-bottom: 10px;
        }
        
        .password-protection label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .password-protection input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .password-protection .btn-container {
            margin-top: 10px;
        }
        
        .password-protection .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .password-protection .unlock-btn {
            background-color: #4CAF50;
            color: white;
        }
        
        .password-protection .unlock-btn:hover {
            background-color: #45a049;
        }
        
        .github-settings {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            display: none;
        }
        
        .github-settings.unlocked {
            display: block;
        }
        
        .github-settings h3 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
        }
        
        .github-settings .form-group {
            margin-bottom: 10px;
        }
        
        .github-settings label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .github-settings input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .github-settings .btn-container {
            margin-top: 10px;
        }
        
        .github-settings .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .github-settings .save-settings-btn {
            background-color: #4CAF50;
            color: white;
        }
        
        .github-settings .save-settings-btn:hover {
            background-color: #45a049;
        }
        
        .github-settings .test-connection-btn {
            background-color: #2196F3;
            color: white;
        }
        
        .github-settings .test-connection-btn:hover {
            background-color: #0b7dda;
        }
        
        .github-settings .toggle-settings-btn {
            background-color: #FF9800;
            color: white;
        }
        
        .github-settings .toggle-settings-btn:hover {
            background-color: #e68900;
        }
        
        .github-settings .lock-settings-btn {
            background-color: #f44336;
            color: white;
        }
        
        .github-settings .lock-settings-btn:hover {
            background-color: #d32f2f;
        }
        
        .github-settings .settings-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .github-settings.collapsed .settings-content {
            display: none;
        }
        
        .error-message {
            color: #d32f2f;
            font-size: 13px;
            margin-top: 5px;
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                margin: 5px;
            }
            
            .container {
                padding: 10px;
                border-radius: 5px;
            }
            
            h1 {
                font-size: 20px;
                margin-bottom: 10px;
            }
            
            h2 {
                font-size: 18px;
                margin-top: 15px;
                margin-bottom: 8px;
            }
            
            .instructions {
                font-size: 12px;
                padding: 8px;
                margin-bottom: 10px;
            }
            
            th, td {
                padding: 6px 4px;
                font-size: 12px;
            }
            
            .edit-btn, .save-btn, .cancel-btn, .set-time-btn {
                padding: 4px 6px;
                font-size: 11px;
            }
            
            .edit-input {
                padding: 4px;
                font-size: 12px;
            }
            
            .notification {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
            
            .polling-status {
                bottom: 5px;
                right: 5px;
                font-size: 10px;
            }
            
            .password-protection, .github-settings {
                padding: 10px;
            }
            
            .password-protection h3, .github-settings h3 {
                font-size: 16px;
            }
            
            .password-protection .btn, .github-settings .btn {
                padding: 6px 10px;
                font-size: 12px;
            }
        }
        
        /* For very small screens */
        @media (max-width: 480px) {
            .container {
                padding: 8px;
            }
            
            h1 {
                font-size: 18px;
            }
            
            h2 {
                font-size: 16px;
            }
            
            .instructions {
                font-size: 11px;
                padding: 6px;
            }
            
            th, td {
                padding: 4px 2px;
                font-size: 11px;
            }
            
            .edit-btn, .save-btn, .cancel-btn, .set-time-btn {
                padding: 3px 5px;
                font-size: 10px;
            }
            
            .edit-input {
                padding: 3px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Boss Respawn Tracker <span id="liveIndicator" class="update-indicator" style="display: none;"></span></h1>
        
        <div id="storageStatus" class="storage-status">
            Connecting to GitHub storage...
        </div>
        
        <div class="github-settings-container">
            <div class="password-protection" id="passwordProtection">
                <h3>GitHub Settings (Password Protected)</h3>
                <div class="form-group">
                    <label for="settingsPassword">Password:</label>
                    <input type="password" id="settingsPassword" placeholder="Enter password to access settings">
                    <div id="passwordError" class="error-message"></div>
                </div>
                <div class="btn-container">
                    <button class="btn unlock-btn" id="unlockSettings">Unlock Settings</button>
                </div>
            </div>
            
            <div class="github-settings" id="githubSettings">
                <h3>GitHub Settings 
                    <button class="btn toggle-settings-btn" id="toggleSettings">Hide</button>
                    <button class="btn lock-settings-btn" id="lockSettings">Lock</button>
                </h3>
                <div class="settings-content">
                    <div class="form-group">
                        <label for="githubOwner">Repository Owner:</label>
                        <input type="text" id="githubOwner" placeholder="Your GitHub username">
                    </div>
                    <div class="form-group">
                        <label for="githubRepo">Repository Name:</label>
                        <input type="text" id="githubRepo" placeholder="Repository name">
                    </div>
                    <div class="form-group">
                        <label for="githubToken">Personal Access Token:</label>
                        <input type="password" id="githubToken" placeholder="Your GitHub PAT with repo scope">
                    </div>
                    <div class="form-group">
                        <label for="githubBranch">Branch:</label>
                        <input type="text" id="githubBranch" value="main">
                    </div>
                    <div class="form-group">
                        <label for="githubPath">File Path:</label>
                        <input type="text" id="githubPath" value="boss_data.json">
                    </div>
                    <div class="btn-container">
                        <button class="btn save-settings-btn" id="saveSettings">Save Settings</button>
                        <button class="btn test-connection-btn" id="testConnection">Test Connection</button>
                    </div>
                    <div class="settings-info">
                        <p>To use this tracker with GitHub Pages:</p>
                        <ol>
                            <li>Create a GitHub repository to store your boss data</li>
                            <li>Generate a Personal Access Token (PAT) with "repo" scope</li>
                            <li>Fill in the settings above and click "Save Settings"</li>
                            <li>Click "Test Connection" to verify your settings</li>
                        </ol>
                        <p>Note: Your PAT is stored locally in your browser and never sent to any server.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <strong>Instructions:</strong> Click the Edit button in each row to modify the date, time, and cooldown. Use the date and time pickers to select values, then click Save to confirm changes. For regular bosses, you can click Set Time to set the death time to the current time. The respawn times will automatically update and the next boss to respawn will be highlighted in light yellow. Time remaining text turns red and bold when a boss has respawned or is the next one to spawn. All data is saved to GitHub and updates in real-time.
        </div>
        
        <div class="table-container">
            <table id="bossTable">
                <thead>
                    <tr>
                        <th>Map</th>
                        <th>Level</th>
                        <th>Name</th>
                        <th>Date</th>
                        <th>Time</th>
                        <th>Spawn Time</th>
                        <th>Next Spawn</th>
                        <th>Time Left</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Regular Bosses -->
                    <tr data-boss-id="venatus" data-cooldown="10" data-death-time="2023-05-15T10:00">
                        <td>Corrupted Basin</td>
                        <td>60</td>
                        <td>Venatus</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">10:00</td>
                        <td class="cooldown-cell">10h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('venatus')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="viorent" data-cooldown="10" data-death-time="2023-05-15T10:00">
                        <td>Cresent Lake</td>
                        <td>65</td>
                        <td>Viorent</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">10:00</td>
                        <td class="cooldown-cell">10h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('viorent')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="ego" data-cooldown="21" data-death-time="2023-05-15T21:00">
                        <td>Ulan Canyon</td>
                        <td>70</td>
                        <td>Ego</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">21:00</td>
                        <td class="cooldown-cell">21h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('ego')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="livera" data-cooldown="24" data-death-time="2023-05-15T00:00">
                        <td>Protector's Ruins</td>
                        <td>75</td>
                        <td>Livera</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">24h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('livera')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="araneo" data-cooldown="24" data-death-time="2023-05-15T00:00">
                        <td>Tyriosa 1F</td>
                        <td>75</td>
                        <td>Araneo</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">24h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('araneo')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="undomiel" data-cooldown="24" data-death-time="2023-05-15T00:00">
                        <td>Secret Lab</td>
                        <td>80</td>
                        <td>Undomiel</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">24h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('undomiel')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="lady-dalia" data-cooldown="18" data-death-time="2023-05-15T18:00">
                        <td>Twilight Hill</td>
                        <td>85</td>
                        <td>Lady Dalia</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">18:00</td>
                        <td class="cooldown-cell">18h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('lady-dalia')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="general-aquleus" data-cooldown="29" data-death-time="2023-05-15T05:00">
                        <td>Tyriosa 2F</td>
                        <td>85</td>
                        <td>General Aquleus</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">05:00</td>
                        <td class="cooldown-cell">29h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('general-aquleus')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="amentis" data-cooldown="29" data-death-time="2023-05-15T05:00">
                        <td>Land of Glory</td>
                        <td>88</td>
                        <td>Amentis</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">05:00</td>
                        <td class="cooldown-cell">29h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('amentis')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="baron-braudmore" data-cooldown="32" data-death-time="2023-05-15T05:00">
                        <td>Battlefield of Templar</td>
                        <td>88</td>
                        <td>Baron Braudmore</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">05:00</td>
                        <td class="cooldown-cell">32h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('baron-braudmore')">Edit</button></td>
                    </tr>
                    <!-- New Regular Bosses -->
                    <tr data-boss-id="wannitas" data-cooldown="48" data-death-time="2023-05-15T00:00">
                        <td>Plateau of Revolution</td>
                        <td>93</td>
                        <td>Wannitas</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">48h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('wannitas')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="metus" data-cooldown="48" data-death-time="2023-05-15T00:00">
                        <td>Plateau of Revolution</td>
                        <td>93</td>
                        <td>Metus</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">48h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('metus')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="duplican" data-cooldown="48" data-death-time="2023-05-15T00:00">
                        <td>Plateau of Revolution</td>
                        <td>93</td>
                        <td>Duplican</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">48h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('duplican')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="shuliar" data-cooldown="35" data-death-time="2023-05-15T00:00">
                        <td>Ruins of the War</td>
                        <td>95</td>
                        <td>Shuliar</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">35h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('shuliar')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="gareth" data-cooldown="32" data-death-time="2023-05-15T00:00">
                        <td>Deadman 1</td>
                        <td>98</td>
                        <td>Gareth</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">32h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('gareth')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="titore" data-cooldown="37" data-death-time="2023-05-15T00:00">
                        <td>Deadman 2</td>
                        <td>98</td>
                        <td>Titore</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">37h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('titore')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="larba" data-cooldown="35" data-death-time="2023-05-15T00:00">
                        <td>Ruins of the War</td>
                        <td>98</td>
                        <td>Larba</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">35h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('larba')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="catena" data-cooldown="35" data-death-time="2023-05-15T00:00">
                        <td>Deadman 3</td>
                        <td>100</td>
                        <td>Catena</td>
                        <td class="date-cell">2023-05-15</td>
                        <td class="time-cell">00:00</td>
                        <td class="cooldown-cell">35h</td>
                        <td class="respawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editRow('catena')">Edit</button></td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <h2>Fixed Bosses</h2>
        <div class="table-container">
            <table id="fixedBossTable">
                <thead>
                    <tr>
                        <th>Map</th>
                        <th>Level</th>
                        <th>Name</th>
                        <th>Spawn Schedule</th>
                        <th>Next Spawn</th>
                        <th>Time Left</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Fixed Bosses -->
                    <tr data-boss-id="clemantis" data-fixed-schedule="Mon 11:30 / Thurs 19:00">
                        <td>Corrupted Basin</td>
                        <td>70</td>
                        <td>Clemantis</td>
                        <td class="schedule-cell">Mon 11:30 / Thurs 19:00</td>
                        <td class="next-spawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editFixedBoss('clemantis')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="saphirus" data-fixed-schedule="Sun 17:00 / Tues 11:30">
                        <td>Cresent Lake</td>
                        <td>80</td>
                        <td>Saphirus</td>
                        <td class="schedule-cell">Sun 17:00 / Tues 11:30</td>
                        <td class="next-spawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editFixedBoss('saphirus')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="neutro" data-fixed-schedule="Tues 19:00 / Thurs 11:30">
                        <td>Desert Screaming</td>
                        <td>80</td>
                        <td>Neutro</td>
                        <td class="schedule-cell">Tues 19:00 / Thurs 11:30</td>
                        <td class="next-spawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editFixedBoss('neutro')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="thymele" data-fixed-schedule="Mon 19:00 / Wed 11:30">
                        <td>Twilight Hill</td>
                        <td>85</td>
                        <td>Thymele</td>
                        <td class="schedule-cell">Mon 19:00 / Wed 11:30</td>
                        <td class="next-spawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editFixedBoss('thymele')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="milavy" data-fixed-schedule="Sat 15:00">
                        <td>Tyriosa 3F</td>
                        <td>90</td>
                        <td>Milavy</td>
                        <td class="schedule-cell">Sat 15:00</td>
                        <td class="next-spawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editFixedBoss('milavy')">Edit</button></td>
                    </tr>
                    <!-- New Fixed Bosses -->
                    <tr data-boss-id="ringor" data-fixed-schedule="Sat 17:00">
                        <td>Ruins of the war</td>
                        <td>95</td>
                        <td>Ringor</td>
                        <td class="schedule-cell">Sat 17:00</td>
                        <td class="next-spawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editFixedBoss('ringor')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="roderick" data-fixed-schedule="Fri 19:00">
                        <td>Garbana 1F</td>
                        <td>95</td>
                        <td>Roderick</td>
                        <td class="schedule-cell">Fri 19:00</td>
                        <td class="next-spawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editFixedBoss('roderick')">Edit</button></td>
                    </tr>
                    <tr data-boss-id="auraq" data-fixed-schedule="Sun 21:00 / Wed 21:00">
                        <td>Garbana 2F</td>
                        <td>100</td>
                        <td>Auraq</td>
                        <td class="schedule-cell">Sun 21:00 / Wed 21:00</td>
                        <td class="next-spawn-cell"></td>
                        <td class="time-left-cell"></td>
                        <td><button class="edit-btn" onclick="editFixedBoss('auraq')">Edit</button></td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="last-updated">
            Last updated: <span id="updateTime"></span>
        </div>
    </div>
    <div class="notification" id="notification">Data saved successfully!</div>
    <div class="polling-status" id="pollingStatus">Checking for updates...</div>
    <script>
        // Default password for GitHub settings
        const SETTINGS_PASSWORD = "admin123"; // Change this to your desired password
        
        // Default death times for each boss
        const defaultDeathTimes = {
            'venatus': '2023-05-15T10:00',
            'viorent': '2023-05-15T10:00',
            'ego': '2023-05-15T21:00',
            'livera': '2023-05-15T00:00',
            'araneo': '2023-05-15T00:00',
            'undomiel': '2023-05-15T00:00',
            'lady-dalia': '2023-05-15T18:00',
            'general-aquleus': '2023-05-15T05:00',
            'amentis': '2023-05-15T05:00',
            'baron-braudmore': '2023-05-15T05:00',
            // New regular bosses
            'wannitas': '2023-05-15T00:00',
            'metus': '2023-05-15T00:00',
            'duplican': '2023-05-15T00:00',
            'shuliar': '2023-05-15T00:00',
            'gareth': '2023-05-15T00:00',
            'titore': '2023-05-15T00:00',
            'larba': '2023-05-15T00:00',
            'catena': '2023-05-15T00:00'
        };
        
        // Default cooldowns for each boss
        const defaultCooldowns = {
            'venatus': '10',
            'viorent': '10',
            'ego': '21',
            'livera': '24',
            'araneo': '24',
            'undomiel': '24',
            'lady-dalia': '18',
            'general-aquleus': '29',
            'amentis': '29',
            'baron-braudmore': '32',
            // New regular bosses
            'wannitas': '48',
            'metus': '48',
            'duplican': '48',
            'shuliar': '35',
            'gareth': '32',
            'titore': '37',
            'larba': '35',
            'catena': '35'
        };
        
        // Fixed schedules for fixed bosses
        const fixedSchedules = {
            'clemantis': 'Mon 11:30 / Thurs 19:00',
            'saphirus': 'Sun 17:00 / Tues 11:30',
            'neutro': 'Tues 19:00 / Thurs 11:30',
            'thymele': 'Mon 19:00 / Wed 11:30',
            'milavy': 'Sat 15:00',
            // New fixed bosses
            'ringor': 'Sat 17:00',
            'roderick': 'Fri 19:00',
            'auraq': 'Sun 21:00 / Wed 21:00'
        };
        
        // Global variables
        let lastUpdateTimestamp = null;
        let pollingInterval = 5000; // Start with 5 seconds
        let minPollingInterval = 1000; // Minimum 1 second
        let maxPollingInterval = 30000; // Maximum 30 seconds
        let pollingTimer = null;
        let isPageVisible = true;
        let consecutiveNoUpdateCount = 0;
        let lastActivityTime = Date.now();
        
        // GitHub settings
        let githubSettings = {
            owner: '',
            repo: '',
            token: '',
            branch: 'main',
            path: 'boss_data.json'
        };
        
        // Check if settings are unlocked
        function isSettingsUnlocked() {
            return sessionStorage.getItem('settingsUnlocked') === 'true';
        }
        
        // Unlock settings
        function unlockSettings() {
            const passwordInput = document.getElementById('settingsPassword');
            const passwordError = document.getElementById('passwordError');
            const password = passwordInput.value;
            
            if (password === SETTINGS_PASSWORD) {
                sessionStorage.setItem('settingsUnlocked', 'true');
                document.getElementById('passwordProtection').style.display = 'none';
                document.getElementById('githubSettings').classList.add('unlocked');
                passwordError.textContent = '';
                showNotification('Settings unlocked successfully!');
            } else {
                passwordError.textContent = 'Incorrect password. Please try again.';
                passwordInput.focus();
            }
        }
        
        // Lock settings
        function lockSettings() {
            sessionStorage.removeItem('settingsUnlocked');
            document.getElementById('passwordProtection').style.display = 'block';
            document.getElementById('githubSettings').classList.remove('unlocked');
            document.getElementById('settingsPassword').value = '';
            document.getElementById('passwordError').textContent = '';
            showNotification('Settings locked.');
        }
        
        // Load GitHub settings from localStorage
        function loadGithubSettings() {
            const savedSettings = localStorage.getItem('githubSettings');
            if (savedSettings) {
                githubSettings = JSON.parse(savedSettings);
                
                // Update UI
                document.getElementById('githubOwner').value = githubSettings.owner;
                document.getElementById('githubRepo').value = githubSettings.repo;
                document.getElementById('githubToken').value = githubSettings.token;
                document.getElementById('githubBranch').value = githubSettings.branch;
                document.getElementById('githubPath').value = githubSettings.path;
            }
        }
        
        // Save GitHub settings to localStorage
        function saveGithubSettings() {
            githubSettings.owner = document.getElementById('githubOwner').value;
            githubSettings.repo = document.getElementById('githubRepo').value;
            githubSettings.token = document.getElementById('githubToken').value;
            githubSettings.branch = document.getElementById('githubBranch').value;
            githubSettings.path = document.getElementById('githubPath').value;
            
            localStorage.setItem('githubSettings', JSON.stringify(githubSettings));
            showNotification('GitHub settings saved successfully!');
        }
        
        // Test GitHub connection
        async function testGithubConnection() {
            if (!githubSettings.owner || !githubSettings.repo || !githubSettings.token) {
                showNotification('Please fill in all required fields (Owner, Repo, Token)', 5000);
                return false;
            }
            
            updateStorageStatus(false, 'Testing GitHub connection...');
            
            try {
                const response = await fetch(`https://api.github.com/repos/${githubSettings.owner}/${githubSettings.repo}`, {
                    headers: {
                        'Authorization': `token ${githubSettings.token}`
                    }
                });
                
                if (response.ok) {
                    updateStorageStatus(true, 'Connected to GitHub successfully!');
                    showNotification('GitHub connection test successful!', 3000);
                    return true;
                } else {
                    const errorData = await response.json();
                    updateStorageStatus(false, `GitHub connection failed: ${errorData.message}`);
                    showNotification(`GitHub connection failed: ${errorData.message}`, 5000);
                    return false;
                }
            } catch (error) {
                updateStorageStatus(false, `GitHub connection error: ${error.message}`);
                showNotification(`GitHub connection error: ${error.message}`, 5000);
                return false;
            }
        }
        
        // Function to save data to GitHub
        async function saveToGitHub(bossData, fixedBossData) {
            if (!githubSettings.owner || !githubSettings.repo || !githubSettings.token) {
                showNotification('GitHub settings not configured. Please configure settings first.', 5000);
                return false;
            }
            
            const data = {
                bossData: bossData,
                fixedBossData: fixedBossData,
                lastUpdated: new Date().toISOString()
            };
            
            try {
                // First, get the current file to retrieve its SHA
                const getFileResponse = await fetch(`https://api.github.com/repos/${githubSettings.owner}/${githubSettings.repo}/contents/${githubSettings.path}`, {
                    headers: {
                        'Authorization': `token ${githubSettings.token}`
                    }
                });
                
                let sha = null;
                if (getFileResponse.ok) {
                    const fileData = await getFileResponse.json();
                    sha = fileData.sha;
                }
                
                // Encode the content to base64
                const content = btoa(JSON.stringify(data, null, 2));
                
                // Create or update the file
                const method = sha ? 'PUT' : 'POST';
                const url = sha 
                    ? `https://api.github.com/repos/${githubSettings.owner}/${githubSettings.repo}/contents/${githubSettings.path}`
                    : `https://api.github.com/repos/${githubSettings.owner}/${githubSettings.repo}/contents/${githubSettings.path}`;
                
                const body = {
                    message: 'Update boss respawn data',
                    content: content,
                    branch: githubSettings.branch
                };
                
                if (sha) {
                    body.sha = sha;
                }
                
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'Authorization': `token ${githubSettings.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    lastUpdateTimestamp = data.lastUpdated;
                    return true;
                } else {
                    const errorData = await response.json();
                    console.error('GitHub API error:', errorData);
                    return false;
                }
            } catch (error) {
                console.error('Error saving to GitHub:', error);
                return false;
            }
        }
        
        // Function to load data from GitHub
        async function loadFromGitHub() {
            if (!githubSettings.owner || !githubSettings.repo) {
                // If no GitHub settings, use default data
                return {
                    bossData: {},
                    fixedBossData: {},
                    lastUpdated: null
                };
            }
            
            try {
                // Try to fetch from GitHub API first
                const response = await fetch(`https://api.github.com/repos/${githubSettings.owner}/${githubSettings.repo}/contents/${githubSettings.path}`, {
                    headers: githubSettings.token ? {
                        'Authorization': `token ${githubSettings.token}`
                    } : {}
                });
                
                if (response.ok) {
                    const fileData = await response.json();
                    const content = atob(fileData.content);
                    const data = JSON.parse(content);
                    return data;
                } else if (response.status === 404) {
                    // File doesn't exist yet, return empty data
                    return {
                        bossData: {},
                        fixedBossData: {},
                        lastUpdated: null
                    };
                } else {
                    // Other error, try to fetch from raw URL as fallback
                    const rawResponse = await fetch(`https://raw.githubusercontent.com/${githubSettings.owner}/${githubSettings.repo}/${githubSettings.branch}/${githubSettings.path}`);
                    
                    if (rawResponse.ok) {
                        const content = await rawResponse.text();
                        const data = JSON.parse(content);
                        return data;
                    } else {
                        // If both methods fail, return empty data
                        return {
                            bossData: {},
                            fixedBossData: {},
                            lastUpdated: null
                        };
                    }
                }
            } catch (error) {
                console.error('Error loading from GitHub:', error);
                return {
                    bossData: {},
                    fixedBossData: {},
                    lastUpdated: null
                };
            }
        }
        
        // Function to check for updates
        async function checkForUpdates() {
            try {
                const data = await loadFromGitHub();
                
                if (!data || !data.lastUpdated) {
                    return false;
                }
                
                // If this is the first time loading, set the timestamp and return
                if (!lastUpdateTimestamp) {
                    lastUpdateTimestamp = data.lastUpdated;
                    return false;
                }
                
                // Check if the data has been updated since our last check
                if (data.lastUpdated !== lastUpdateTimestamp) {
                    lastUpdateTimestamp = data.lastUpdated;
                    return true;
                }
                
                return false;
            } catch (error) {
                console.error('Error checking for updates:', error);
                return false;
            }
        }
        
        // Function to update polling interval based on activity
        function updatePollingInterval(hasUpdates) {
            if (hasUpdates) {
                // Reset counter on update
                consecutiveNoUpdateCount = 0;
                
                // If we got an update, speed up polling temporarily
                if (pollingInterval > minPollingInterval) {
                    pollingInterval = Math.max(minPollingInterval, pollingInterval / 2);
                    restartPolling();
                }
            } else {
                // No update, gradually slow down polling
                consecutiveNoUpdateCount++;
                
                if (consecutiveNoUpdateCount > 2 && pollingInterval < maxPollingInterval) {
                    pollingInterval = Math.min(maxPollingInterval, pollingInterval * 1.5);
                    restartPolling();
                }
            }
            
            // Update polling status display
            updatePollingStatus();
        }
        
        // Function to restart polling with new interval
        function restartPolling() {
            if (pollingTimer) {
                clearInterval(pollingTimer);
            }
            
            if (isPageVisible) {
                pollingTimer = setInterval(refreshDataIfUpdated, pollingInterval);
            }
        }
        
        // Function to update polling status display
        function updatePollingStatus() {
            const statusElement = document.getElementById('pollingStatus');
            if (statusElement) {
                let intervalText = '';
                if (pollingInterval < 2000) {
                    intervalText = 'Checking frequently';
                } else if (pollingInterval < 10000) {
                    intervalText = 'Checking every ' + (pollingInterval / 1000).toFixed(0) + 's';
                } else {
                    intervalText = 'Checking every ' + (pollingInterval / 1000).toFixed(0) + 's';
                }
                statusElement.textContent = intervalText;
            }
        }
        
        // Function to update storage status indicator
        function updateStorageStatus(connected, message) {
            const statusElement = document.getElementById('storageStatus');
            if (connected) {
                statusElement.textContent = message || 'Connected to GitHub storage';
                statusElement.className = 'storage-status storage-connected';
            } else {
                statusElement.textContent = message || 'GitHub storage unavailable - using defaults';
                statusElement.className = 'storage-status storage-error';
            }
        }
        
        // Function to save data to file
        async function saveToFile() {
            // Save regular boss data
            const rows = document.querySelectorAll('#bossTable tbody tr');
            const bossData = {};
            
            rows.forEach(row => {
                const bossId = row.dataset.bossId;
                const deathTime = row.dataset.deathTime;
                const cooldown = row.dataset.cooldown;
                
                if (bossId && deathTime && cooldown) {
                    bossData[bossId] = {
                        deathTime: deathTime,
                        cooldown: cooldown
                    };
                }
            });
            
            // Save fixed boss data
            const fixedRows = document.querySelectorAll('#fixedBossTable tbody tr');
            const fixedBossData = {};
            
            fixedRows.forEach(row => {
                const bossId = row.dataset.bossId;
                const schedule = row.dataset.fixedSchedule;
                
                if (bossId && schedule) {
                    fixedBossData[bossId] = {
                        schedule: schedule
                    };
                }
            });
            
            try {
                const success = await saveToGitHub(bossData, fixedBossData);
                if (success) {
                    showNotification('Data saved to GitHub successfully!');
                    updateStorageStatus(true, 'Data saved to GitHub');
                    
                    // Update the last update timestamp
                    const data = await loadFromGitHub();
                    if (data && data.lastUpdated) {
                        lastUpdateTimestamp = data.lastUpdated;
                    }
                    
                    // Update activity time
                    lastActivityTime = Date.now();
                    
                    // Speed up polling after activity
                    if (pollingInterval > minPollingInterval) {
                        pollingInterval = minPollingInterval;
                        restartPolling();
                    }
                    
                    return true;
                } else {
                    showNotification('Failed to save to GitHub. Please check your settings and try again.');
                    updateStorageStatus(false, 'Failed to save to GitHub');
                    return false;
                }
            } catch (error) {
                showNotification('Failed to save to GitHub. Please check your settings and try again.');
                updateStorageStatus(false, 'Failed to save to GitHub');
                return false;
            }
        }
        
        // Function to load data from file
        async function loadFromFile() {
            try {
                const data = await loadFromGitHub();
                
                if (!data) {
                    updateStorageStatus(false, 'Failed to load from GitHub - using defaults');
                    return false;
                }
                
                // Update the last update timestamp
                if (data.lastUpdated) {
                    lastUpdateTimestamp = data.lastUpdated;
                }
                
                // Process regular boss data
                if (data.bossData) {
                    Object.keys(data.bossData).forEach(bossId => {
                        const row = document.querySelector(`#bossTable tr[data-boss-id="${bossId}"]`);
                        if (row) {
                            const bossInfo = data.bossData[bossId];
                            row.dataset.deathTime = bossInfo.deathTime;
                            row.dataset.cooldown = bossInfo.cooldown;
                            
                            // Update display values
                            const deathTime = new Date(bossInfo.deathTime);
                            const dateCell = row.querySelector('.date-cell');
                            const timeCell = row.querySelector('.time-cell');
                            const cooldownCell = row.querySelector('.cooldown-cell');
                            
                            if (dateCell) {
                                // Format date as YYYY-MM-DD in local time
                                const year = deathTime.getFullYear();
                                const month = String(deathTime.getMonth() + 1).padStart(2, '0');
                                const day = String(deathTime.getDate()).padStart(2, '0');
                                dateCell.textContent = `${year}-${month}-${day}`;
                            }
                            
                            if (timeCell) {
                                const hours = String(deathTime.getHours()).padStart(2, '0');
                                const minutes = String(deathTime.getMinutes()).padStart(2, '0');
                                timeCell.textContent = `${hours}:${minutes}`;
                            }
                            
                            if (cooldownCell) {
                                cooldownCell.textContent = `${bossInfo.cooldown}h`;
                            }
                        }
                    });
                }
                
                // Process fixed boss data
                if (data.fixedBossData) {
                    Object.keys(data.fixedBossData).forEach(bossId => {
                        const row = document.querySelector(`#fixedBossTable tr[data-boss-id="${bossId}"]`);
                        if (row) {
                            const bossInfo = data.fixedBossData[bossId];
                            row.dataset.fixedSchedule = bossInfo.schedule;
                            
                            // Update display values
                            const scheduleCell = row.querySelector('.schedule-cell');
                            if (scheduleCell) {
                                scheduleCell.textContent = bossInfo.schedule;
                            }
                        }
                    });
                }
                
                updateStorageStatus(true, 'Data loaded from GitHub');
                return true;
            } catch (error) {
                updateStorageStatus(false, 'Failed to load from GitHub - using defaults');
                return false;
            }
        }
        
        // Function to show notification
        function showNotification(message, duration = 3000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }
        
        // Function to calculate respawn time and time remaining
        function calculateRespawn(deathTimeStr, cooldownHours) {
            // Parse death time from ISO format
            const deathDateTime = new Date(deathTimeStr);
            
            if (isNaN(deathDateTime.getTime())) {
                return {
                    respawnDateTime: null,
                    respawnDate: 'Invalid Date',
                    respawnTime: 'Invalid Time',
                    timeRemaining: 'Invalid Input',
                    timeRemainingMs: Infinity
                };
            }
            
            // Calculate respawn time
            const respawnDateTime = new Date(deathDateTime);
            respawnDateTime.setHours(respawnDateTime.getHours() + parseInt(cooldownHours));
            
            // Calculate time remaining
            const now = new Date();
            const timeRemainingMs = respawnDateTime - now;
            const timeRemainingHours = Math.floor(timeRemainingMs / (1000 * 60 * 60));
            const timeRemainingMinutes = Math.floor((timeRemainingMs % (1000 * 60 * 60)) / (1000 * 60));
            
            // Format respawn time
            const respawnDate = respawnDateTime.toLocaleDateString();
            const respawnTime = respawnDateTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            // Format time remaining
            let timeRemainingStr = '';
            if (timeRemainingMs > 0) {
                timeRemainingStr = `${timeRemainingHours}h ${timeRemainingMinutes}m left`;
            } else {
                timeRemainingStr = 'Respawned';
            }
            
            return {
                respawnDateTime,
                respawnDate,
                respawnTime,
                timeRemaining: timeRemainingStr,
                timeRemainingMs
            };
        }
        
        // Function to calculate next fixed boss spawn
        function calculateNextFixedSpawn(scheduleStr) {
            // Parse schedule string (e.g., "Mon 11:30 / Thurs 19:00" or "Sat 15:00")
            const scheduleParts = scheduleStr.split('/');
            const now = new Date();
            let nextSpawn = null;
            let minTimeRemaining = Infinity;
            
            // Day mapping
            const dayMap = {
                'Sun': 0,
                'Mon': 1,
                'Tues': 2,
                'Wed': 3,
                'Thurs': 4,
                'Fri': 5,
                'Sat': 6
            };
            
            // Check each schedule part
            scheduleParts.forEach(part => {
                const trimmedPart = part.trim();
                const dayTimeMatch = trimmedPart.match(/^(\w+)\s+(\d{1,2}):(\d{2})$/);
                
                if (dayTimeMatch) {
                    const dayName = dayTimeMatch[1];
                    const hours = parseInt(dayTimeMatch[2]);
                    const minutes = parseInt(dayTimeMatch[3]);
                    
                    const dayOfWeek = dayMap[dayName];
                    if (dayOfWeek !== undefined) {
                        // Create a date for this week's spawn
                        const spawnDate = new Date(now);
                        spawnDate.setDate(now.getDate() + (dayOfWeek + 7 - now.getDay()) % 7);
                        spawnDate.setHours(hours, minutes, 0, 0);
                        
                        // If this spawn time has already passed this week, add 7 days
                        if (spawnDate <= now) {
                            spawnDate.setDate(spawnDate.getDate() + 7);
                        }
                        
                        // Calculate time remaining
                        const timeRemainingMs = spawnDate - now;
                        
                        // If this is the next spawn, remember it
                        if (timeRemainingMs < minTimeRemaining && timeRemainingMs > 0) {
                            minTimeRemaining = timeRemainingMs;
                            nextSpawn = {
                                spawnDateTime: spawnDate,
                                timeRemainingMs: timeRemainingMs
                            };
                        }
                    }
                }
            });
            
            // If no valid spawn time found, return default
            if (!nextSpawn) {
                return {
                    spawnDateTime: null,
                    spawnTime: 'Invalid schedule',
                    timeRemaining: 'Invalid schedule',
                    timeRemainingMs: Infinity
                };
            }
            
            // Format spawn time
            const spawnTime = nextSpawn.spawnDateTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const spawnDay = nextSpawn.spawnDateTime.toLocaleDateString();
            
            // Format time remaining
            const timeRemainingHours = Math.floor(nextSpawn.timeRemainingMs / (1000 * 60 * 60));
            const timeRemainingMinutes = Math.floor((nextSpawn.timeRemainingMs % (1000 * 60 * 60)) / (1000 * 60));
            
            let timeRemainingStr = '';
            if (nextSpawn.timeRemainingMs > 0) {
                timeRemainingStr = `${timeRemainingHours}h ${timeRemainingMinutes}m left`;
            } else {
                timeRemainingStr = 'Respawned';
            }
            
            return {
                spawnDateTime: nextSpawn.spawnDateTime,
                spawnTime: `${spawnTime} (${spawnDay})`,
                timeRemaining: timeRemainingStr,
                timeRemainingMs: nextSpawn.timeRemainingMs
            };
        }
        
        // Function to update respawn times and highlight next boss
        function updateRespawnTimes() {
            let nextRespawnRow = null;
            let nextFixedBossRow = null;
            let minTimeRemaining = Infinity;
            let minFixedTimeRemaining = Infinity;
            
            // Update regular bosses
            const rows = document.querySelectorAll('#bossTable tbody tr');
            rows.forEach(row => {
                const respawnCell = row.querySelector('.respawn-cell');
                const timeLeftCell = row.querySelector('.time-left-cell');
                const deathTime = row.dataset.deathTime;
                const cooldown = row.dataset.cooldown;
                
                const respawnData = calculateRespawn(deathTime, cooldown);
                
                // Update respawn cell
                respawnCell.textContent = `${respawnData.respawnTime} (${respawnData.respawnDate})`;
                
                // Update time left cell
                timeLeftCell.innerHTML = `<span class="time-remaining">${respawnData.timeRemaining}</span>`;
                
                // Check if this is the next boss to respawn
                if (respawnData.timeRemainingMs > 0 && respawnData.timeRemainingMs < minTimeRemaining) {
                    minTimeRemaining = respawnData.timeRemainingMs;
                    nextRespawnRow = row;
                }
            });
            
            // Update fixed bosses
            const fixedRows = document.querySelectorAll('#fixedBossTable tbody tr');
            fixedRows.forEach(row => {
                const nextSpawnCell = row.querySelector('.next-spawn-cell');
                const timeLeftCell = row.querySelector('.time-left-cell');
                const schedule = row.dataset.fixedSchedule;
                
                const spawnData = calculateNextFixedSpawn(schedule);
                
                // Update next spawn cell
                nextSpawnCell.textContent = spawnData.spawnTime;
                
                // Update time left cell
                timeLeftCell.innerHTML = `<span class="time-remaining">${spawnData.timeRemaining}</span>`;
                
                // Check if this is the next fixed boss to spawn
                if (spawnData.timeRemainingMs > 0 && spawnData.timeRemainingMs < minFixedTimeRemaining) {
                    minFixedTimeRemaining = spawnData.timeRemainingMs;
                    nextFixedBossRow = row;
                }
            });
            
            // Remove previous highlights for both regular and fixed bosses
            rows.forEach(row => {
                row.classList.remove('next-regular-respawn');
            });
            fixedRows.forEach(row => {
                row.classList.remove('next-fixed-respawn');
            });
            
            // Highlight next regular boss to respawn
            if (nextRespawnRow) {
                nextRespawnRow.classList.add('next-regular-respawn');
            }
            
            // Highlight next fixed boss to respawn
            if (nextFixedBossRow) {
                nextFixedBossRow.classList.add('next-fixed-respawn');
            }
            
            // Update time remaining text color and font weight
            // First, reset all time-remaining elements to default
            document.querySelectorAll('.time-remaining').forEach(element => {
                element.classList.remove('time-urgent');
                element.classList.remove('time-bold');
            });
            
            // Then, make time red and bold for bosses that have respawned or are next to spawn
            rows.forEach(row => {
                const timeLeftCell = row.querySelector('.time-left-cell');
                const timeRemainingSpan = timeLeftCell.querySelector('.time-remaining');
                const deathTime = row.dataset.deathTime;
                const cooldown = row.dataset.cooldown;
                
                const respawnData = calculateRespawn(deathTime, cooldown);
                
                // Make red and bold if boss has respawned or is the next regular boss to respawn
                if (respawnData.timeRemainingMs <= 0 || row === nextRespawnRow) {
                    timeRemainingSpan.classList.add('time-urgent');
                    timeRemainingSpan.classList.add('time-bold');
                }
            });
            
            fixedRows.forEach(row => {
                const timeLeftCell = row.querySelector('.time-left-cell');
                const timeRemainingSpan = timeLeftCell.querySelector('.time-remaining');
                const schedule = row.dataset.fixedSchedule;
                
                const spawnData = calculateNextFixedSpawn(schedule);
                
                // Make red and bold if boss has spawned or is the next fixed boss to spawn
                if (spawnData.timeRemainingMs <= 0 || row === nextFixedBossRow) {
                    timeRemainingSpan.classList.add('time-urgent');
                    timeRemainingSpan.classList.add('time-bold');
                }
            });
            
            // Update last updated time
            updateTime();
        }
        
        // Function to edit a row
        function editRow(bossId) {
            const row = document.querySelector(`#bossTable tr[data-boss-id="${bossId}"]`);
            if (!row) return;
            
            // Get cells
            const dateCell = row.querySelector('.date-cell');
            const timeCell = row.querySelector('.time-cell');
            const cooldownCell = row.querySelector('.cooldown-cell');
            const actionCell = row.querySelector('td:last-child');
            
            // Get current values
            const deathTime = row.dataset.deathTime;
            const cooldown = row.dataset.cooldown;
            
            // Parse death time
            const deathDateTime = new Date(deathTime);
            
            // Format date as YYYY-MM-DD for the input
            const year = deathDateTime.getFullYear();
            const month = String(deathDateTime.getMonth() + 1).padStart(2, '0');
            const day = String(deathDateTime.getDate()).padStart(2, '0');
            const dateValue = `${year}-${month}-${day}`;
            
            const hours = String(deathDateTime.getHours()).padStart(2, '0');
            const minutes = String(deathDateTime.getMinutes()).padStart(2, '0');
            const timeValue = `${hours}:${minutes}`;
            
            // Create date input
            const dateInput = document.createElement('input');
            dateInput.type = 'date';
            dateInput.className = 'edit-input';
            dateInput.value = dateValue;
            
            // Create time input
            const timeInput = document.createElement('input');
            timeInput.type = 'time';
            timeInput.className = 'edit-input';
            timeInput.value = timeValue;
            
            // Create cooldown input
            const cooldownInput = document.createElement('input');
            cooldownInput.type = 'number';
            cooldownInput.className = 'edit-input';
            cooldownInput.min = '1';
            cooldownInput.max = '168';
            cooldownInput.value = cooldown;
            
            // Create set time button
            const setTimeBtn = document.createElement('button');
            setTimeBtn.textContent = 'Set Time';
            setTimeBtn.className = 'set-time-btn';
            
            // Create save button
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.className = 'save-btn';
            
            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'cancel-btn';
            
            // Store original content
            const originalDateContent = dateCell.textContent;
            const originalTimeContent = timeCell.textContent;
            const originalCooldownContent = cooldownCell.textContent;
            const originalActionContent = actionCell.innerHTML;
            
            // Replace cell content with inputs
            dateCell.innerHTML = '';
            dateCell.appendChild(dateInput);
            
            timeCell.innerHTML = '';
            timeCell.appendChild(timeInput);
            
            cooldownCell.innerHTML = '';
            cooldownCell.appendChild(cooldownInput);
            
            actionCell.innerHTML = '';
            actionCell.appendChild(setTimeBtn);
            actionCell.appendChild(saveBtn);
            actionCell.appendChild(cancelBtn);
            
            // Focus on date input
            dateInput.focus();
            
            // Set time function
            const setTimeFunction = () => {
                const now = new Date();
                
                // Format date as YYYY-MM-DD for the input
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                dateInput.value = `${year}-${month}-${day}`;
                
                // Format time as HH:MM for the input
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                timeInput.value = `${hours}:${minutes}`;
            };
            
            // Save function
            const saveChanges = async () => {
                const newDateValue = dateInput.value;
                const newTimeValue = timeInput.value;
                const newCooldownValue = cooldownInput.value;
                
                // Validate inputs
                if (!newDateValue || !newTimeValue) {
                    alert('Please enter valid date and time');
                    return;
                }
                
                if (!newCooldownValue || parseInt(newCooldownValue) <= 0 || parseInt(newCooldownValue) > 168) {
                    alert('Please enter a valid cooldown between 1 and 168 hours');
                    return;
                }
                
                // Update data attributes
                const newDeathTime = `${newDateValue}T${newTimeValue}`;
                row.dataset.deathTime = newDeathTime;
                row.dataset.cooldown = newCooldownValue;
                
                // Update display values
                dateCell.textContent = newDateValue;
                timeCell.textContent = newTimeValue;
                cooldownCell.textContent = `${newCooldownValue}h`;
                
                // Restore action cell
                actionCell.innerHTML = originalActionContent;
                
                // Save to file and update respawn times
                const fileSaveSuccess = await saveToFile();
                if (fileSaveSuccess) {
                    updateRespawnTimes();
                }
            };
            
            // Cancel function
            const cancelChanges = () => {
                dateCell.textContent = originalDateContent;
                timeCell.textContent = originalTimeContent;
                cooldownCell.textContent = originalCooldownContent;
                actionCell.innerHTML = originalActionContent;
            };
            
            // Add event listeners
            setTimeBtn.addEventListener('click', setTimeFunction);
            saveBtn.addEventListener('click', saveChanges);
            cancelBtn.addEventListener('click', cancelChanges);
            
            // Enter key to save
            [dateInput, timeInput, cooldownInput].forEach(input => {
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        saveChanges();
                    } else if (e.key === 'Escape') {
                        cancelChanges();
                    }
                });
            });
        }
        
        // Function to edit a fixed boss row
        function editFixedBoss(bossId) {
            const row = document.querySelector(`#fixedBossTable tr[data-boss-id="${bossId}"]`);
            if (!row) return;
            
            // Get cells
            const scheduleCell = row.querySelector('.schedule-cell');
            const actionCell = row.querySelector('td:last-child');
            
            // Get current value
            const schedule = row.dataset.fixedSchedule;
            
            // Create schedule input
            const scheduleInput = document.createElement('input');
            scheduleInput.type = 'text';
            scheduleInput.className = 'edit-input';
            scheduleInput.value = schedule;
            scheduleInput.placeholder = 'e.g., Mon 11:30 / Thurs 19:00';
            
            // Create save button
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.className = 'save-btn';
            
            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'cancel-btn';
            
            // Store original content
            const originalScheduleContent = scheduleCell.textContent;
            const originalActionContent = actionCell.innerHTML;
            
            // Replace cell content with input
            scheduleCell.innerHTML = '';
            scheduleCell.appendChild(scheduleInput);
            
            actionCell.innerHTML = '';
            actionCell.appendChild(saveBtn);
            actionCell.appendChild(cancelBtn);
            
            // Focus on input
            scheduleInput.focus();
            scheduleInput.select();
            
            // Save function
            const saveChanges = async () => {
                const newSchedule = scheduleInput.value.trim();
                
                // Validate input
                if (!newSchedule) {
                    alert('Please enter a valid schedule');
                    return;
                }
                
                // Update data attribute
                row.dataset.fixedSchedule = newSchedule;
                
                // Update display value
                scheduleCell.textContent = newSchedule;
                
                // Restore action cell
                actionCell.innerHTML = originalActionContent;
                
                // Save to file and update respawn times
                const fileSaveSuccess = await saveToFile();
                if (fileSaveSuccess) {
                    updateRespawnTimes();
                }
            };
            
            // Cancel function
            const cancelChanges = () => {
                scheduleCell.textContent = originalScheduleContent;
                actionCell.innerHTML = originalActionContent;
            };
            
            // Add event listeners
            saveBtn.addEventListener('click', saveChanges);
            cancelBtn.addEventListener('click', cancelChanges);
            
            // Enter key to save
            scheduleInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    saveChanges();
                } else if (e.key === 'Escape') {
                    cancelChanges();
                }
            });
        }
        
        // Update the last updated time
        function updateTime() {
            const now = new Date();
            document.getElementById('updateTime').textContent = now.toLocaleString();
        }
        
        // Function to refresh data if updates are available
        async function refreshDataIfUpdated() {
            const hasUpdates = await checkForUpdates();
            
            if (hasUpdates) {
                // Show live indicator
                const liveIndicator = document.getElementById('liveIndicator');
                liveIndicator.style.display = 'inline-block';
                
                // Show notification
                showNotification('Data has been updated by another user!', 5000);
                
                // Reload data
                await loadFromFile();
                
                // Update respawn times
                updateRespawnTimes();
                
                // Hide live indicator after 5 seconds
                setTimeout(() => {
                    liveIndicator.style.display = 'none';
                }, 5000);
            }
            
            // Update polling interval based on whether we found updates
            updatePollingInterval(hasUpdates);
        }
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', function() {
            isPageVisible = !document.hidden;
            
            if (isPageVisible) {
                // Page became visible, restart polling
                restartPolling();
                
                // Check for updates immediately
                refreshDataIfUpdated();
            } else {
                // Page became hidden, stop polling
                if (pollingTimer) {
                    clearInterval(pollingTimer);
                    pollingTimer = null;
                }
            }
        });
        
        // Handle user activity
        ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'].forEach(function(eventName) {
            document.addEventListener(eventName, function() {
                lastActivityTime = Date.now();
                
                // If user is active, speed up polling
                if (pollingInterval > minPollingInterval) {
                    pollingInterval = minPollingInterval;
                    restartPolling();
                }
            }, true);
        });
        
        // Initialize the table
        window.onload = async function() {
            // Check if settings are unlocked
            if (isSettingsUnlocked()) {
                document.getElementById('passwordProtection').style.display = 'none';
                document.getElementById('githubSettings').classList.add('unlocked');
            } else {
                document.getElementById('passwordProtection').style.display = 'block';
                document.getElementById('githubSettings').classList.remove('unlocked');
            }
            
            // Load GitHub settings
            loadGithubSettings();
            
            // Set up event listeners for GitHub settings
            document.getElementById('saveSettings').addEventListener('click', saveGithubSettings);
            document.getElementById('testConnection').addEventListener('click', testGithubConnection);
            document.getElementById('toggleSettings').addEventListener('click', function() {
                const settingsDiv = document.getElementById('githubSettings');
                settingsDiv.classList.toggle('collapsed');
                this.textContent = settingsDiv.classList.contains('collapsed') ? 'Show' : 'Hide';
            });
            document.getElementById('lockSettings').addEventListener('click', lockSettings);
            document.getElementById('unlockSettings').addEventListener('click', unlockSettings);
            
            // Handle Enter key in password field
            document.getElementById('settingsPassword').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    unlockSettings();
                }
            });
            
            // Try to load data from GitHub
            const fileLoadSuccess = await loadFromFile();
            
            // If file load failed, initialize with defaults
            if (!fileLoadSuccess) {
                // Initialize regular bosses with defaults
                const rows = document.querySelectorAll('#bossTable tbody tr');
                rows.forEach(row => {
                    const bossId = row.dataset.bossId;
                    if (bossId && defaultDeathTimes[bossId] && defaultCooldowns[bossId]) {
                        row.dataset.deathTime = defaultDeathTimes[bossId];
                        row.dataset.cooldown = defaultCooldowns[bossId];
                    }
                });
                
                // Initialize fixed bosses with defaults
                const fixedRows = document.querySelectorAll('#fixedBossTable tbody tr');
                fixedRows.forEach(row => {
                    const bossId = row.dataset.bossId;
                    if (bossId && fixedSchedules[bossId]) {
                        row.dataset.fixedSchedule = fixedSchedules[bossId];
                    }
                });
                
                // Try to save the default data to GitHub
                await saveToFile();
            }
            
            // Update respawn times - this ensures time remaining is calculated on page load
            updateRespawnTimes();
            
            // Update time every minute
            setInterval(updateRespawnTimes, 60000);
            
            // Start polling
            restartPolling();
            
            // Update polling status display
            updatePollingStatus();
        };
    </script>
</body>
</html>
