<script>
    // Google Sheets configuration
    const SHEET_ID = '1rAih1TLrFmuhB1DlElj4S1mMk_Aas9d7K2H-MyW0Ts0'; // Your sheet ID
    const API_KEY = 'AIzaSyD_y-jSPMrqN4ucjMBEGW3frA9AvzhjaTw'; // Replace with your actual API key
    
    // Default death times for each boss
    const defaultDeathTimes = {
        'venatus': '2023-05-15T10:00',
        'viorent': '2023-05-15T10:00',
        'ego': '2023-05-15T21:00',
        'livera': '2023-05-15T00:00',
        'araneo': '2023-05-15T00:00',
        'undomiel': '2023-05-15T00:00',
        'lady-dalia': '2023-05-15T18:00',
        'general-aquleus': '2023-05-15T05:00',
        'amentis': '2023-05-15T05:00',
        'baron-braudmore': '2023-05-15T05:00',
        'wannitas': '2023-05-15T00:00',
        'metus': '2023-05-15T00:00',
        'duplican': '2023-05-15T00:00',
        'shuliar': '2023-05-15T00:00',
        'gareth': '2023-05-15T00:00',
        'titore': '2023-05-15T00:00',
        'larba': '2023-05-15T00:00',
        'catena': '2023-05-15T00:00'
    };
    
    // Default cooldowns for each boss (in hours)
    const defaultCooldowns = {
        'venatus': 10,
        'viorent': 10,
        'ego': 21,
        'livera': 24,
        'araneo': 24,
        'undomiel': 24,
        'lady-dalia': 18,
        'general-aquleus': 29,
        'amentis': 29,
        'baron-braudmore': 32,
        'wannitas': 48,
        'metus': 48,
        'duplican': 48,
        'shuliar': 35,
        'gareth': 32,
        'titore': 37,
        'larba': 35,
        'catena': 35
    };
    
    // Default schedules for fixed bosses
    const defaultFixedSchedules = {
        'clemantis': 'Mon 11:30 / Thurs 19:00',
        'saphirus': 'Sun 17:00 / Tues 11:30',
        'neutro': 'Tues 19:00 / Thurs 11:30',
        'thymele': 'Mon 19:00 / Wed 11:30',
        'milavy': 'Sat 15:00',
        'ringor': 'Sat 17:00',
        'roderick': 'Fri 19:00',
        'auraq': 'Sun 21:00 / Wed 21:00'
    };
    
    // Initialize the page
    document.addEventListener('DOMContentLoaded', function() {
        // Set up debug toggle
        document.getElementById('toggleDebug').addEventListener('click', function() {
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo.style.display === 'none' || debugInfo.style.display === '') {
                debugInfo.style.display = 'block';
                this.textContent = 'Hide Debug Info';
                updateDebugInfo();
            } else {
                debugInfo.style.display = 'none';
                this.textContent = 'Show Debug Info';
            }
        });
        
        // Set up auto-refresh
        const autoRefreshCheckbox = document.getElementById('autoRefresh');
        autoRefreshCheckbox.addEventListener('change', function() {
            if (this.checked) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        });
        
        // Set up manual refresh button
        document.getElementById('refreshData').addEventListener('click', loadDataFromSheets);
        
        // Load data from Google Sheets
        loadDataFromSheets();
        
        // Start auto-refresh if enabled
        if (autoRefreshCheckbox.checked) {
            startAutoRefresh();
        }
    });
    
    let refreshInterval;
    
    function startAutoRefresh() {
        refreshInterval = setInterval(loadDataFromSheets, 10000); // Refresh every 10 seconds
        document.getElementById('pollingStatus').textContent = 'Auto-refresh enabled';
    }
    
    function stopAutoRefresh() {
        clearInterval(refreshInterval);
        document.getElementById('pollingStatus').textContent = 'Auto-refresh disabled';
    }
    
    // Function to load data from Google Sheets
    async function loadDataFromSheets() {
        try {
            document.getElementById('pollingStatus').textContent = 'Checking for updates...';
            
            // Load regular bosses data
            const regularBossesUrl = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/Regular%20Bosses!A2:Z100?key=${API_KEY}`;
            const regularBossesResponse = await fetch(regularBossesUrl);
            
            if (!regularBossesResponse.ok) {
                throw new Error(`HTTP error! Status: ${regularBossesResponse.status}`);
            }
            
            const regularBossesData = await regularBossesResponse.json();
            
            // Load fixed bosses data
            const fixedBossesUrl = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/Fixed%20Bosses!A2:Z100?key=${API_KEY}`;
            const fixedBossesResponse = await fetch(fixedBossesUrl);
            
            if (!fixedBossesResponse.ok) {
                throw new Error(`HTTP error! Status: ${fixedBossesResponse.status}`);
            }
            
            const fixedBossesData = await fixedBossesResponse.json();
            
            // Process the data
            processRegularBossesData(regularBossesData.values);
            processFixedBossesData(fixedBossesData.values);
            
            // Update status
            document.getElementById('storageStatus').textContent = 'Connected to Google Sheets';
            document.getElementById('storageStatus').className = 'storage-status storage-connected';
            document.getElementById('liveIndicator').style.display = 'inline-block';
            
            // Calculate respawn times
            calculateRespawnTimes();
            
            // Update last updated time
            updateLastUpdatedTime();
            
            document.getElementById('pollingStatus').textContent = 'Last update: ' + new Date().toLocaleTimeString();
        } catch (error) {
            console.error('Error loading data from Google Sheets:', error);
            document.getElementById('storageStatus').textContent = 'Failed to connect to Google Sheets. Using local data.';
            document.getElementById('storageStatus').className = 'storage-status storage-error';
            
            // Fallback to local data
            useLocalData();
            
            document.getElementById('pollingStatus').textContent = 'Connection error';
        }
    }
    
    // Function to process regular bosses data
    function processRegularBossesData(values) {
        if (!values || values.length === 0) {
            console.log('No regular bosses data found');
            return;
        }
        
        values.forEach(row => {
            if (row.length >= 3) {
                const bossId = row[0];
                const deathTime = row[1];
                const cooldown = row[2];
                
                const bossRow = document.querySelector(`#bossTable tr[data-boss-id="${bossId}"]`);
                if (bossRow) {
                    bossRow.setAttribute('data-death-time', deathTime);
                    bossRow.setAttribute('data-cooldown', cooldown);
                    
                    // Update the displayed date and time
                    const deathDate = new Date(deathTime);
                    bossRow.querySelector('.date-cell').textContent = deathDate.toISOString().split('T')[0];
                    bossRow.querySelector('.time-cell').textContent = deathDate.toTimeString().substring(0, 5);
                    bossRow.querySelector('.cooldown-cell').textContent = cooldown + 'h';
                }
            }
        });
    }
    
    // Function to process fixed bosses data
    function processFixedBossesData(values) {
        if (!values || values.length === 0) {
            console.log('No fixed bosses data found');
            return;
        }
        
        values.forEach(row => {
            if (row.length >= 2) {
                const bossId = row[0];
                const schedule = row[1];
                
                const bossRow = document.querySelector(`#fixedBossTable tr[data-boss-id="${bossId}"]`);
                if (bossRow) {
                    bossRow.setAttribute('data-fixed-schedule', schedule);
                    bossRow.querySelector('.schedule-cell').textContent = schedule;
                }
            }
        });
    }
    
    // Function to use local data if Google Sheets fails
    function useLocalData() {
        // Set default death times for regular bosses
        Object.keys(defaultDeathTimes).forEach(bossId => {
            const bossRow = document.querySelector(`#bossTable tr[data-boss-id="${bossId}"]`);
            if (bossRow) {
                bossRow.setAttribute('data-death-time', defaultDeathTimes[bossId]);
                bossRow.setAttribute('data-cooldown', defaultCooldowns[bossId]);
                
                // Update the displayed date and time
                const deathDate = new Date(defaultDeathTimes[bossId]);
                bossRow.querySelector('.date-cell').textContent = deathDate.toISOString().split('T')[0];
                bossRow.querySelector('.time-cell').textContent = deathDate.toTimeString().substring(0, 5);
                bossRow.querySelector('.cooldown-cell').textContent = defaultCooldowns[bossId] + 'h';
            }
        });
        
        // Set default schedules for fixed bosses
        Object.keys(defaultFixedSchedules).forEach(bossId => {
            const bossRow = document.querySelector(`#fixedBossTable tr[data-boss-id="${bossId}"]`);
            if (bossRow) {
                bossRow.setAttribute('data-fixed-schedule', defaultFixedSchedules[bossId]);
                bossRow.querySelector('.schedule-cell').textContent = defaultFixedSchedules[bossId];
            }
        });
        
        // Calculate respawn times
        calculateRespawnTimes();
        
        // Update last updated time
        updateLastUpdatedTime();
    }
    
    // Function to calculate respawn times
    function calculateRespawnTimes() {
        const now = new Date();
        let nextRegularRespawnTime = null;
        let nextFixedRespawnTime = null;
        let nextRegularBossRow = null;
        let nextFixedBossRow = null;
        
        // Calculate regular bosses respawn times
        document.querySelectorAll('#bossTable tbody tr').forEach(row => {
            const bossId = row.getAttribute('data-boss-id');
            const deathTimeStr = row.getAttribute('data-death-time');
            const cooldownHours = parseInt(row.getAttribute('data-cooldown'));
            
            if (deathTimeStr && cooldownHours) {
                const deathTime = new Date(deathTimeStr);
                const respawnTime = new Date(deathTime.getTime() + cooldownHours * 60 * 60 * 1000);
                
                // Format respawn time
                const respawnDate = respawnTime.toISOString().split('T')[0];
                const respawnHours = respawnTime.getHours().toString().padStart(2, '0');
                const respawnMinutes = respawnTime.getMinutes().toString().padStart(2, '0');
                const respawnTimeStr = `${respawnDate} ${respawnHours}:${respawnMinutes}`;
                
                row.querySelector('.respawn-cell').textContent = respawnTimeStr;
                
                // Calculate time remaining
                let timeRemaining = respawnTime - now;
                let timeRemainingStr = '';
                let timeClass = 'time-remaining';
                
                if (timeRemaining <= 0) {
                    timeRemainingStr = 'Respawned!';
                    timeClass = 'time-urgent time-bold';
                } else {
                    const days = Math.floor(timeRemaining / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
                    
                    if (days > 0) {
                        timeRemainingStr = `${days}d ${hours}h ${minutes}m`;
                    } else if (hours > 0) {
                        timeRemainingStr = `${hours}h ${minutes}m`;
                    } else {
                        timeRemainingStr = `${minutes}m`;
                        timeClass = 'time-urgent';
                    }
                    
                    // Check if this is the next respawn
                    if (!nextRegularRespawnTime || respawnTime < nextRegularRespawnTime) {
                        nextRegularRespawnTime = respawnTime;
                        nextRegularBossRow = row;
                    }
                }
                
                const timeLeftCell = row.querySelector('.time-left-cell');
                timeLeftCell.textContent = timeRemainingStr;
                timeLeftCell.className = 'time-left-cell ' + timeClass;
            }
        });
        
        // Calculate fixed bosses respawn times
        document.querySelectorAll('#fixedBossTable tbody tr').forEach(row => {
            const bossId = row.getAttribute('data-boss-id');
            const scheduleStr = row.getAttribute('data-fixed-schedule');
            
            if (scheduleStr) {
                const schedules = scheduleStr.split('/');
                let nextSpawnTime = null;
                
                schedules.forEach(schedule => {
                    const [day, time] = schedule.trim().split(' ');
                    const [hours, minutes] = time.split(':').map(Number);
                    
                    // Calculate next spawn time for this schedule
                    const spawnTime = getNextSpawnTime(day, hours, minutes);
                    
                    if (!nextSpawnTime || spawnTime < nextSpawnTime) {
                        nextSpawnTime = spawnTime;
                    }
                });
                
                if (nextSpawnTime) {
                    // Format next spawn time
                    const spawnDate = nextSpawnTime.toISOString().split('T')[0];
                    const spawnHours = nextSpawnTime.getHours().toString().padStart(2, '0');
                    const spawnMinutes = nextSpawnTime.getMinutes().toString().padStart(2, '0');
                    const spawnTimeStr = `${spawnDate} ${spawnHours}:${spawnMinutes}`;
                    
                    row.querySelector('.next-spawn-cell').textContent = spawnTimeStr;
                    
                    // Calculate time remaining
                    let timeRemaining = nextSpawnTime - now;
                    let timeRemainingStr = '';
                    let timeClass = 'time-remaining';
                    
                    if (timeRemaining <= 0) {
                        timeRemainingStr = 'Spawned!';
                        timeClass = 'time-urgent time-bold';
                    } else {
                        const days = Math.floor(timeRemaining / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
                        
                        if (days > 0) {
                            timeRemainingStr = `${days}d ${hours}h ${minutes}m`;
                        } else if (hours > 0) {
                            timeRemainingStr = `${hours}h ${minutes}m`;
                        } else {
                            timeRemainingStr = `${minutes}m`;
                            timeClass = 'time-urgent';
                        }
                        
                        // Check if this is the next respawn
                        if (!nextFixedRespawnTime || nextSpawnTime < nextFixedRespawnTime) {
                            nextFixedRespawnTime = nextSpawnTime;
                            nextFixedBossRow = row;
                        }
                    }
                    
                    const timeLeftCell = row.querySelector('.time-left-cell');
                    timeLeftCell.textContent = timeRemainingStr;
                    timeLeftCell.className = 'time-left-cell ' + timeClass;
                }
            }
        });
        
        // Highlight next regular respawn
        document.querySelectorAll('#bossTable tbody tr').forEach(row => {
            row.classList.remove('next-regular-respawn');
        });
        if (nextRegularBossRow) {
            nextRegularBossRow.classList.add('next-regular-respawn');
        }
        
        // Highlight next fixed respawn
        document.querySelectorAll('#fixedBossTable tbody tr').forEach(row => {
            row.classList.remove('next-fixed-respawn');
        });
        if (nextFixedBossRow) {
            nextFixedBossRow.classList.add('next-fixed-respawn');
        }
    }
    
    // Helper function to get next spawn time for a fixed boss
    function getNextSpawnTime(dayStr, hours, minutes) {
        const now = new Date();
        const dayMap = {
            'Sun': 0,
            'Mon': 1,
            'Tues': 2,
            'Wed': 3,
            'Thurs': 4,
            'Fri': 5,
            'Sat': 6
        };
        
        const targetDay = dayMap[dayStr];
        if (targetDay === undefined) return now;
        
        const result = new Date(now);
        result.setHours(hours, minutes, 0, 0);
        
        // If today is the target day and the time hasn't passed yet
        if (now.getDay() === targetDay && result > now) {
            return result;
        }
        
        // Find the next occurrence
        let daysUntilNext = (targetDay - now.getDay() + 7) % 7;
        if (daysUntilNext === 0 && result <= now) {
            daysUntilNext = 7;
        }
        
        result.setDate(now.getDate() + daysUntilNext);
        return result;
    }
    
    // Function to update the last updated time
    function updateLastUpdatedTime() {
        document.getElementById('updateTime').textContent = new Date().toLocaleString();
    }
    
    // Function to update debug information
    function updateDebugInfo() {
        const debugInfo = document.getElementById('debugInfo');
        debugInfo.innerHTML = `
            <p>Current Time: ${new Date().toLocaleString()}</p>
            <p>Google Sheets ID: ${SHEET_ID}</p>
            <p>API Key: ${API_KEY ? 'Set' : 'Not Set'}</p>
            <p>Auto-refresh: ${document.getElementById('autoRefresh').checked ? 'Enabled' : 'Disabled'}</p>
        `;
    }
    
    // Function to edit a regular boss row
    function editRow(bossId) {
        const row = document.querySelector(`#bossTable tr[data-boss-id="${bossId}"]`);
        if (!row) return;
        
        const dateCell = row.querySelector('.date-cell');
        const timeCell = row.querySelector('.time-cell');
        const cooldownCell = row.querySelector('.cooldown-cell');
        const actionCell = row.querySelector('td:last-child');
        
        // Get current values
        const currentDate = dateCell.textContent;
        const currentTime = timeCell.textContent;
        const currentCooldown = cooldownCell.textContent.replace('h', '');
        
        // Replace cells with input fields
        dateCell.innerHTML = `<input type="date" class="edit-input" id="edit-date-${bossId}" value="${currentDate}">`;
        timeCell.innerHTML = `<input type="time" class="edit-input" id="edit-time-${bossId}" value="${currentTime}">`;
        cooldownCell.innerHTML = `<input type="number" class="edit-input" id="edit-cooldown-${bossId}" value="${currentCooldown}" min="1">`;
        
        // Replace action cell with save/cancel buttons
        actionCell.innerHTML = `
            <div class="edit-controls">
                <button class="save-btn" onclick="saveRow('${bossId}')">Save</button>
                <button class="cancel-btn" onclick="cancelEdit('${bossId}')">Cancel</button>
                <button class="set-time-btn" onclick="setCurrentTime('${bossId}')">Set Time</button>
            </div>
        `;
    }
    
    // Function to save a regular boss row
    function saveRow(bossId) {
        const row = document.querySelector(`#bossTable tr[data-boss-id="${bossId}"]`);
        if (!row) return;
        
        const dateInput = document.getElementById(`edit-date-${bossId}`);
        const timeInput = document.getElementById(`edit-time-${bossId}`);
        const cooldownInput = document.getElementById(`edit-cooldown-${bossId}`);
        
        if (!dateInput || !timeInput || !cooldownInput) return;
        
        const dateValue = dateInput.value;
        const timeValue = timeInput.value;
        const cooldownValue = cooldownInput.value;
        
        if (!dateValue || !timeValue || !cooldownValue) {
            showNotification('Please fill in all fields', true);
            return;
        }
        
        // Update the row data
        const deathTime = `${dateValue}T${timeValue}`;
        row.setAttribute('data-death-time', deathTime);
        row.setAttribute('data-cooldown', cooldownValue);
        
        // Update the displayed values
        row.querySelector('.date-cell').textContent = dateValue;
        row.querySelector('.time-cell').textContent = timeValue;
        row.querySelector('.cooldown-cell').textContent = cooldownValue + 'h';
        
        // Restore the action cell
        row.querySelector('td:last-child').innerHTML = `<button class="edit-btn" onclick="editRow('${bossId}')">Edit</button>`;
        
        // Calculate respawn times
        calculateRespawnTimes();
        
        // Save to Google Sheets
        saveToGoogleSheets(bossId, deathTime, cooldownValue);
        
        // Show notification
        showNotification('Boss data updated successfully!');
    }
    
    // Function to cancel editing a regular boss row
    function cancelEdit(bossId) {
        const row = document.querySelector(`#bossTable tr[data-boss-id="${bossId}"]`);
        if (!row) return;
        
        // Get the original values from the data attributes
        const deathTime = row.getAttribute('data-death-time');
        const cooldown = row.getAttribute('data-cooldown');
        
        if (deathTime && cooldown) {
            const deathDate = new Date(deathTime);
            const dateStr = deathDate.toISOString().split('T')[0];
            const timeStr = deathDate.toTimeString().substring(0, 5);
            
            // Restore the cells
            row.querySelector('.date-cell').textContent = dateStr;
            row.querySelector('.time-cell').textContent = timeStr;
            row.querySelector('.cooldown-cell').textContent = cooldown + 'h';
        }
        
        // Restore the action cell
        row.querySelector('td:last-child').innerHTML = `<button class="edit-btn" onclick="editRow('${bossId}')">Edit</button>`;
    }
    
    // Function to set current time for a regular boss
    function setCurrentTime(bossId) {
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0];
        const timeStr = now.toTimeString().substring(0, 5);
        
        const dateInput = document.getElementById(`edit-date-${bossId}`);
        const timeInput = document.getElementById(`edit-time-${bossId}`);
        
        if (dateInput && timeInput) {
            dateInput.value = dateStr;
            timeInput.value = timeStr;
        }
    }
    
    // Function to edit a fixed boss row
    function editFixedBoss(bossId) {
        const row = document.querySelector(`#fixedBossTable tr[data-boss-id="${bossId}"]`);
        if (!row) return;
        
        const scheduleCell = row.querySelector('.schedule-cell');
        const actionCell = row.querySelector('td:last-child');
        
        // Get current value
        const currentSchedule = scheduleCell.textContent;
        
        // Replace cell with input field
        scheduleCell.innerHTML = `<input type="text" class="edit-input" id="edit-schedule-${bossId}" value="${currentSchedule}">`;
        
        // Replace action cell with save/cancel buttons
        actionCell.innerHTML = `
            <div class="edit-controls">
                <button class="save-btn" onclick="saveFixedBoss('${bossId}')">Save</button>
                <button class="cancel-btn" onclick="cancelFixedEdit('${bossId}')">Cancel</button>
            </div>
        `;
    }
    
    // Function to save a fixed boss row
    function saveFixedBoss(bossId) {
        const row = document.querySelector(`#fixedBossTable tr[data-boss-id="${bossId}"]`);
        if (!row) return;
        
        const scheduleInput = document.getElementById(`edit-schedule-${bossId}`);
        
        if (!scheduleInput) return;
        
        const scheduleValue = scheduleInput.value;
        
        if (!scheduleValue) {
            showNotification('Please enter a schedule', true);
            return;
        }
        
        // Update the row data
        row.setAttribute('data-fixed-schedule', scheduleValue);
        
        // Update the displayed value
        row.querySelector('.schedule-cell').textContent = scheduleValue;
        
        // Restore the action cell
        row.querySelector('td:last-child').innerHTML = `<button class="edit-btn" onclick="editFixedBoss('${bossId}')">Edit</button>`;
        
        // Calculate respawn times
        calculateRespawnTimes();
        
        // Save to Google Sheets
        saveFixedBossToGoogleSheets(bossId, scheduleValue);
        
        // Show notification
        showNotification('Fixed boss schedule updated successfully!');
    }
    
    // Function to cancel editing a fixed boss row
    function cancelFixedEdit(bossId) {
        const row = document.querySelector(`#fixedBossTable tr[data-boss-id="${bossId}"]`);
        if (!row) return;
        
        // Get the original value from the data attribute
        const schedule = row.getAttribute('data-fixed-schedule');
        
        if (schedule) {
            // Restore the cell
            row.querySelector('.schedule-cell').textContent = schedule;
        }
        
        // Restore the action cell
        row.querySelector('td:last-child').innerHTML = `<button class="edit-btn" onclick="editFixedBoss('${bossId}')">Edit</button>`;
    }
    
    // Function to save regular boss data to Google Sheets
    async function saveToGoogleSheets(bossId, deathTime, cooldown) {
        try {
            // This is a simplified implementation
            // In a real application, you would use the Google Sheets API to update the sheet
            console.log(`Saving to Google Sheets: ${bossId}, ${deathTime}, ${cooldown}`);
            
            // For now, we'll just show a notification
            // In a production app, you would make an API call to update the sheet
        } catch (error) {
            console.error('Error saving to Google Sheets:', error);
            showNotification('Error saving to Google Sheets', true);
        }
    }
    
    // Function to save fixed boss data to Google Sheets
    async function saveFixedBossToGoogleSheets(bossId, schedule) {
        try {
            // This is a simplified implementation
            // In a real application, you would use the Google Sheets API to update the sheet
            console.log(`Saving fixed boss to Google Sheets: ${bossId}, ${schedule}`);
            
            // For now, we'll just show a notification
            // In a production app, you would make an API call to update the sheet
        } catch (error) {
            console.error('Error saving fixed boss to Google Sheets:', error);
            showNotification('Error saving to Google Sheets', true);
        }
    }
    
    // Function to show a notification
    function showNotification(message, isError = false) {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.className = isError ? 'notification error' : 'notification';
        notification.style.display = 'block';
        
        // Hide the notification after 3 seconds
        setTimeout(() => {
            notification.style.display = 'none';
        }, 3000);
    }
</script>
